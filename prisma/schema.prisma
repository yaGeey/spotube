generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

generator json {
  provider = "prisma-json-types-generator"
  // output   = "../generated/json-schema"
}

datasource db {
  provider = "sqlite"
}

model MasterTrack {
  id           Int     @id @default(autoincrement())
  thumbnailUrl String?

  title        String
  titleLatin   String?
  artists      String // Comma separated artist names
  artistsLatin String?
  script       String?

  spotify SpotifyTrack?

  defaultYtVideo   YoutubeVideo?  @relation("MasterTrackDefaultVideo", fields: [defaultYtVideoId], references: [id])
  defaultYtVideoId String?
  yt               YoutubeVideo[] @relation("MasterTrackVideos")
  playlistItems    PlaylistItem[]

  lastFM LastFM?
  genius Genius?
}

model SpotifyTrack {
  id           String @id // Spotify Track ID
  title        String
  /// [SpotifyPlaylistItem] 
  fullResponse Json // TODO not playlistitem

  masterTrackId Int?         @unique
  masterTrack   MasterTrack? @relation(fields: [masterTrackId], references: [id], onDelete: Cascade)

  @@index([masterTrackId])
}

model YoutubeVideo {
  id           String   @id
  title        String
  author       String
  // authorId     String // TODO on Author object
  duration     Int // seconds
  views        Int
  publishedAt  DateTime
  thumbnailUrl String
  ///// [YtFullResponse]
  //full_response Json
  index        Int?

  masterTracks     MasterTrack[] @relation("MasterTrackVideos")
  usedAsDefaultFor MasterTrack[] @relation("MasterTrackDefaultVideo")
}

model Playlist {
  id           Int            @id @default(autoincrement())
  title        String
  description  String?
  thumbnailUrl String?
  origin       PlaylistOrigin
  url          String?

  playlistItems     PlaylistItem[]
  inCombinedPlaylists CombinedPlaylist[]

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  spotifyMetadata   SpotifyPlaylist? @relation(fields: [spotifyMetadataId], references: [id], onDelete: Cascade)
  youtubeMetadata   YoutubePlaylist? @relation(fields: [youtubeMetadataId], references: [id], onDelete: Cascade)
  spotifyMetadataId String?          @unique
  youtubeMetadataId String?          @unique
}

model PlaylistItem {
  id       Int      @id @default(autoincrement())
  position Int
  addedAt  DateTime @default(now())

  playlist   Playlist    @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  playlistId Int
  track      MasterTrack @relation(fields: [trackId], references: [id])
  trackId    Int

  @@unique([playlistId, position])
}

model CombinedPlaylist {
  id           Int     @id @default(autoincrement())
  title        String
  description  String?
  thumbnailUrl String?

  playlists Playlist[]

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

enum PlaylistOrigin {
  YOUTUBE
  SPOTIFY
  LOCAL
}

model YoutubePlaylist {
  id           String     @id
  fullResponse Json
  playlists    Playlist[]
}

model SpotifyPlaylist {
  id           String     @id
  snapshotId   String
  /// [SpotifyPlaylist]
  fullResponse Json
  playlists    Playlist[]
}

model LastFM {
  id     Int   @id @default(autoincrement())
  /// [LastFMTrack]
  track  Json?
  /// [LastFMAlbum]
  album  Json?
  /// [LastFMArtist]
  artist Json?

  masterTrackId Int         @unique
  masterTrack   MasterTrack @relation(fields: [masterTrackId], references: [id])
}

model Genius {
  query        String @id
  lyrics       String
  fullResponse Json

  masterTrackId Int         @unique
  masterTrack   MasterTrack @relation(fields: [masterTrackId], references: [id])
}

model AI {
  id        Int        @id @default(autoincrement())
  model     String
  type      PromptType
  title     String
  artists   String
  createdAt DateTime   @default(now())
}

enum PromptType {
  TITLE_ARTIST_PARSING
}
